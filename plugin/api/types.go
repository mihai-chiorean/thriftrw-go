// Code generated by thriftrw
// @generated

package api

import (
	"errors"
	"fmt"
	"github.com/thriftrw/thriftrw-go/wire"
	"strings"
)

type Argument struct {
	Name string `json:"name"`
	Type *Type  `json:"type"`
}

func (v *Argument) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Type == nil {
		return w, errors.New("field Type of Argument is required")
	}
	w, err = v.Type.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Type_Read(w wire.Value) (*Type, error) {
	var v Type
	err := v.FromWire(w)
	return &v, err
}

func (v *Argument) FromWire(w wire.Value) error {
	var err error
	nameIsSet := false
	typeIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Type, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				typeIsSet = true
			}
		}
	}
	if !nameIsSet {
		return errors.New("field Name of Argument is required")
	}
	if !typeIsSet {
		return errors.New("field Type of Argument is required")
	}
	return nil
}

func (v *Argument) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Type: %v", v.Type)
	i++
	return fmt.Sprintf("Argument{%v}", strings.Join(fields[:i], ", "))
}

type Feature int32

const (
	FeatureGenerator Feature = 0
)

func (v Feature) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *Feature) FromWire(w wire.Value) error {
	*v = (Feature)(w.GetI32())
	return nil
}

func (v Feature) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "Generator"
	}
	return fmt.Sprintf("Feature(%d)", w)
}

type Function struct {
	Name       string      `json:"name"`
	Arguments  []*Argument `json:"arguments"`
	ReturnType *Type       `json:"returnType,omitempty"`
}

type _List_Argument_ValueList []*Argument

func (v _List_Argument_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Argument_ValueList) Size() int {
	return len(v)
}

func (_List_Argument_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Argument_ValueList) Close() {
}

func (v *Function) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Arguments == nil {
		return w, errors.New("field Arguments of Function is required")
	}
	w, err = wire.NewValueList(_List_Argument_ValueList(v.Arguments)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.ReturnType != nil {
		w, err = v.ReturnType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Argument_Read(w wire.Value) (*Argument, error) {
	var v Argument
	err := v.FromWire(w)
	return &v, err
}

func _List_Argument_Read(l wire.ValueList) ([]*Argument, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Argument, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Argument_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *Function) FromWire(w wire.Value) error {
	var err error
	nameIsSet := false
	argumentsIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Arguments, err = _List_Argument_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				argumentsIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.ReturnType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	if !nameIsSet {
		return errors.New("field Name of Function is required")
	}
	if !argumentsIsSet {
		return errors.New("field Arguments of Function is required")
	}
	return nil
}

func (v *Function) String() string {
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Arguments: %v", v.Arguments)
	i++
	if v.ReturnType != nil {
		fields[i] = fmt.Sprintf("ReturnType: %v", v.ReturnType)
		i++
	}
	return fmt.Sprintf("Function{%v}", strings.Join(fields[:i], ", "))
}

type GenerateRequest struct {
	Services map[int32]*Service `json:"services"`
}

type _Map_I32_Service_MapItemList map[int32]*Service

func (m _Map_I32_Service_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Service_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Service_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Service_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I32_Service_MapItemList) Close() {
}

func (v *GenerateRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Services == nil {
		return w, errors.New("field Services of GenerateRequest is required")
	}
	w, err = wire.NewValueMap(_Map_I32_Service_MapItemList(v.Services)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Service_Read(w wire.Value) (*Service, error) {
	var v Service
	err := v.FromWire(w)
	return &v, err
}

func _Map_I32_Service_Read(m wire.MapItemList) (map[int32]*Service, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[int32]*Service, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Service_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *GenerateRequest) FromWire(w wire.Value) error {
	var err error
	servicesIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Services, err = _Map_I32_Service_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				servicesIsSet = true
			}
		}
	}
	if !servicesIsSet {
		return errors.New("field Services of GenerateRequest is required")
	}
	return nil
}

func (v *GenerateRequest) String() string {
	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Services: %v", v.Services)
	i++
	return fmt.Sprintf("GenerateRequest{%v}", strings.Join(fields[:i], ", "))
}

type GenerateResponse struct {
	Files map[string][]byte `json:"files"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {
}

func (v *GenerateResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Files == nil {
		return w, errors.New("field Files of GenerateResponse is required")
	}
	w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.Files)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *GenerateResponse) FromWire(w wire.Value) error {
	var err error
	filesIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Files, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				filesIsSet = true
			}
		}
	}
	if !filesIsSet {
		return errors.New("field Files of GenerateResponse is required")
	}
	return nil
}

func (v *GenerateResponse) String() string {
	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Files: %v", v.Files)
	i++
	return fmt.Sprintf("GenerateResponse{%v}", strings.Join(fields[:i], ", "))
}

type GeneratorError struct {
	Message *string `json:"message,omitempty"`
}

func (v *GeneratorError) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *GeneratorError) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GeneratorError) String() string {
	var fields [1]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	return fmt.Sprintf("GeneratorError{%v}", strings.Join(fields[:i], ", "))
}

func (v *GeneratorError) Error() string {
	return v.String()
}

type HandshakeError struct {
	Message *string `json:"message,omitempty"`
}

func (v *HandshakeError) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *HandshakeError) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *HandshakeError) String() string {
	var fields [1]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	return fmt.Sprintf("HandshakeError{%v}", strings.Join(fields[:i], ", "))
}

func (v *HandshakeError) Error() string {
	return v.String()
}

type HandshakeRequest struct{}

func (v *HandshakeRequest) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *HandshakeRequest) FromWire(w wire.Value) error {
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}
	return nil
}

func (v *HandshakeRequest) String() string {
	var fields [0]string
	i := 0
	return fmt.Sprintf("HandshakeRequest{%v}", strings.Join(fields[:i], ", "))
}

type HandshakeResponse struct {
	Name       string    `json:"name"`
	ApiVersion string    `json:"apiVersion"`
	Features   []Feature `json:"features"`
}

type _List_Feature_ValueList []Feature

func (v _List_Feature_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Feature_ValueList) Size() int {
	return len(v)
}

func (_List_Feature_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Feature_ValueList) Close() {
}

func (v *HandshakeResponse) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	w, err = wire.NewValueString(v.ApiVersion), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Features == nil {
		return w, errors.New("field Features of HandshakeResponse is required")
	}
	w, err = wire.NewValueList(_List_Feature_ValueList(v.Features)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Feature_Read(w wire.Value) (Feature, error) {
	var v Feature
	err := v.FromWire(w)
	return v, err
}

func _List_Feature_Read(l wire.ValueList) ([]Feature, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make([]Feature, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Feature_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *HandshakeResponse) FromWire(w wire.Value) error {
	var err error
	nameIsSet := false
	apiVersionIsSet := false
	featuresIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.ApiVersion, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				apiVersionIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Features, err = _List_Feature_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				featuresIsSet = true
			}
		}
	}
	if !nameIsSet {
		return errors.New("field Name of HandshakeResponse is required")
	}
	if !apiVersionIsSet {
		return errors.New("field ApiVersion of HandshakeResponse is required")
	}
	if !featuresIsSet {
		return errors.New("field Features of HandshakeResponse is required")
	}
	return nil
}

func (v *HandshakeResponse) String() string {
	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("ApiVersion: %v", v.ApiVersion)
	i++
	fields[i] = fmt.Sprintf("Features: %v", v.Features)
	i++
	return fmt.Sprintf("HandshakeResponse{%v}", strings.Join(fields[:i], ", "))
}

type KeyValueSliceType struct {
	KeyType   *Type `json:"keyType"`
	ValueType *Type `json:"valueType"`
}

func (v *KeyValueSliceType) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.KeyType == nil {
		return w, errors.New("field KeyType of KeyValueSliceType is required")
	}
	w, err = v.KeyType.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.ValueType == nil {
		return w, errors.New("field ValueType of KeyValueSliceType is required")
	}
	w, err = v.ValueType.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *KeyValueSliceType) FromWire(w wire.Value) error {
	var err error
	keyTypeIsSet := false
	valueTypeIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.KeyType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				keyTypeIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ValueType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				valueTypeIsSet = true
			}
		}
	}
	if !keyTypeIsSet {
		return errors.New("field KeyType of KeyValueSliceType is required")
	}
	if !valueTypeIsSet {
		return errors.New("field ValueType of KeyValueSliceType is required")
	}
	return nil
}

func (v *KeyValueSliceType) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("KeyType: %v", v.KeyType)
	i++
	fields[i] = fmt.Sprintf("ValueType: %v", v.ValueType)
	i++
	return fmt.Sprintf("KeyValueSliceType{%v}", strings.Join(fields[:i], ", "))
}

type MapType struct {
	KeyType   *Type `json:"keyType"`
	ValueType *Type `json:"valueType"`
}

func (v *MapType) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.KeyType == nil {
		return w, errors.New("field KeyType of MapType is required")
	}
	w, err = v.KeyType.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.ValueType == nil {
		return w, errors.New("field ValueType of MapType is required")
	}
	w, err = v.ValueType.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *MapType) FromWire(w wire.Value) error {
	var err error
	keyTypeIsSet := false
	valueTypeIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.KeyType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				keyTypeIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ValueType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				valueTypeIsSet = true
			}
		}
	}
	if !keyTypeIsSet {
		return errors.New("field KeyType of MapType is required")
	}
	if !valueTypeIsSet {
		return errors.New("field ValueType of MapType is required")
	}
	return nil
}

func (v *MapType) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("KeyType: %v", v.KeyType)
	i++
	fields[i] = fmt.Sprintf("ValueType: %v", v.ValueType)
	i++
	return fmt.Sprintf("MapType{%v}", strings.Join(fields[:i], ", "))
}

type Service struct {
	Name      string      `json:"name"`
	Package   string      `json:"package"`
	Directory string      `json:"directory"`
	ParentId  *int32      `json:"parentId,omitempty"`
	Functions []*Function `json:"functions"`
}

type _List_Function_ValueList []*Function

func (v _List_Function_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Function_ValueList) Size() int {
	return len(v)
}

func (_List_Function_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Function_ValueList) Close() {
}

func (v *Service) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	w, err = wire.NewValueString(v.Package), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	w, err = wire.NewValueString(v.Directory), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.ParentId != nil {
		w, err = wire.NewValueI32(*(v.ParentId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Functions == nil {
		return w, errors.New("field Functions of Service is required")
	}
	w, err = wire.NewValueList(_List_Function_ValueList(v.Functions)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Function_Read(w wire.Value) (*Function, error) {
	var v Function
	err := v.FromWire(w)
	return &v, err
}

func _List_Function_Read(l wire.ValueList) ([]*Function, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Function, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Function_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *Service) FromWire(w wire.Value) error {
	var err error
	nameIsSet := false
	packageIsSet := false
	directoryIsSet := false
	functionsIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Package, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				packageIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.Directory, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				directoryIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ParentId = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Functions, err = _List_Function_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				functionsIsSet = true
			}
		}
	}
	if !nameIsSet {
		return errors.New("field Name of Service is required")
	}
	if !packageIsSet {
		return errors.New("field Package of Service is required")
	}
	if !directoryIsSet {
		return errors.New("field Directory of Service is required")
	}
	if !functionsIsSet {
		return errors.New("field Functions of Service is required")
	}
	return nil
}

func (v *Service) String() string {
	var fields [5]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Package: %v", v.Package)
	i++
	fields[i] = fmt.Sprintf("Directory: %v", v.Directory)
	i++
	if v.ParentId != nil {
		fields[i] = fmt.Sprintf("ParentId: %v", *(v.ParentId))
		i++
	}
	fields[i] = fmt.Sprintf("Functions: %v", v.Functions)
	i++
	return fmt.Sprintf("Service{%v}", strings.Join(fields[:i], ", "))
}

type SimpleType int32

const (
	SimpleTypeBool        SimpleType = 0
	SimpleTypeByte        SimpleType = 1
	SimpleTypeInt7        SimpleType = 2
	SimpleTypeInt15       SimpleType = 3
	SimpleTypeInt31       SimpleType = 4
	SimpleTypeInt63       SimpleType = 5
	SimpleTypeFloat63     SimpleType = 6
	SimpleTypeString      SimpleType = 7
	SimpleTypeStructEmpty SimpleType = 8
)

func (v SimpleType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *SimpleType) FromWire(w wire.Value) error {
	*v = (SimpleType)(w.GetI32())
	return nil
}

func (v SimpleType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "Bool"
	case 1:
		return "Byte"
	case 2:
		return "Int7"
	case 3:
		return "Int15"
	case 4:
		return "Int31"
	case 5:
		return "Int63"
	case 6:
		return "Float63"
	case 7:
		return "String"
	case 8:
		return "StructEmpty"
	}
	return fmt.Sprintf("SimpleType(%d)", w)
}

type SliceType struct {
	ValueType *Type `json:"valueType"`
}

func (v *SliceType) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ValueType == nil {
		return w, errors.New("field ValueType of SliceType is required")
	}
	w, err = v.ValueType.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *SliceType) FromWire(w wire.Value) error {
	var err error
	valueTypeIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ValueType, err = _Type_Read(field.Value)
				if err != nil {
					return err
				}
				valueTypeIsSet = true
			}
		}
	}
	if !valueTypeIsSet {
		return errors.New("field ValueType of SliceType is required")
	}
	return nil
}

func (v *SliceType) String() string {
	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("ValueType: %v", v.ValueType)
	i++
	return fmt.Sprintf("SliceType{%v}", strings.Join(fields[:i], ", "))
}

type Type struct {
	Info    *TypeInfo `json:"info"`
	Pointer *bool     `json:"pointer,omitempty"`
}

func _bool_ptr(v bool) *bool {
	return &v
}

func (v *Type) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Info == nil {
		return w, errors.New("field Info of Type is required")
	}
	w, err = v.Info.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Pointer == nil {
		v.Pointer = _bool_ptr(false)
	}
	{
		w, err = wire.NewValueBool(*(v.Pointer)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TypeInfo_Read(w wire.Value) (*TypeInfo, error) {
	var v TypeInfo
	err := v.FromWire(w)
	return &v, err
}

func (v *Type) FromWire(w wire.Value) error {
	var err error
	infoIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Info, err = _TypeInfo_Read(field.Value)
				if err != nil {
					return err
				}
				infoIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Pointer = &x
				if err != nil {
					return err
				}
			}
		}
	}
	if !infoIsSet {
		return errors.New("field Info of Type is required")
	}
	if v.Pointer == nil {
		v.Pointer = _bool_ptr(false)
	}
	return nil
}

func (v *Type) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Info: %v", v.Info)
	i++
	if v.Pointer != nil {
		fields[i] = fmt.Sprintf("Pointer: %v", *(v.Pointer))
		i++
	}
	return fmt.Sprintf("Type{%v}", strings.Join(fields[:i], ", "))
}

type TypeInfo struct {
	SimpleType    *SimpleType        `json:"simpleType,omitempty"`
	SliceType     *SliceType         `json:"sliceType,omitempty"`
	KeyValueSlice *KeyValueSliceType `json:"keyValueSlice,omitempty"`
	MapType       *MapType           `json:"mapType,omitempty"`
	ReferenceType *TypeReference     `json:"referenceType,omitempty"`
}

func (v *TypeInfo) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.SimpleType != nil {
		w, err = v.SimpleType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SliceType != nil {
		w, err = v.SliceType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.KeyValueSlice != nil {
		w, err = v.KeyValueSlice.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.MapType != nil {
		w, err = v.MapType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.ReferenceType != nil {
		w, err = v.ReferenceType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if i != 1 {
		return wire.Value{}, fmt.Errorf("TypeInfo should have exactly one field: got %v fields", i)
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SimpleType_Read(w wire.Value) (SimpleType, error) {
	var v SimpleType
	err := v.FromWire(w)
	return v, err
}

func _SliceType_Read(w wire.Value) (*SliceType, error) {
	var v SliceType
	err := v.FromWire(w)
	return &v, err
}

func _KeyValueSliceType_Read(w wire.Value) (*KeyValueSliceType, error) {
	var v KeyValueSliceType
	err := v.FromWire(w)
	return &v, err
}

func _MapType_Read(w wire.Value) (*MapType, error) {
	var v MapType
	err := v.FromWire(w)
	return &v, err
}

func _TypeReference_Read(w wire.Value) (*TypeReference, error) {
	var v TypeReference
	err := v.FromWire(w)
	return &v, err
}

func (v *TypeInfo) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x SimpleType
				x, err = _SimpleType_Read(field.Value)
				v.SimpleType = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.SliceType, err = _SliceType_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.KeyValueSlice, err = _KeyValueSliceType_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.MapType, err = _MapType_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TStruct {
				v.ReferenceType, err = _TypeReference_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	count := 0
	if v.SimpleType != nil {
		count++
	}
	if v.SliceType != nil {
		count++
	}
	if v.KeyValueSlice != nil {
		count++
	}
	if v.MapType != nil {
		count++
	}
	if v.ReferenceType != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("TypeInfo should have exactly one field: got %v fields", count)
	}
	return nil
}

func (v *TypeInfo) String() string {
	var fields [5]string
	i := 0
	if v.SimpleType != nil {
		fields[i] = fmt.Sprintf("SimpleType: %v", *(v.SimpleType))
		i++
	}
	if v.SliceType != nil {
		fields[i] = fmt.Sprintf("SliceType: %v", v.SliceType)
		i++
	}
	if v.KeyValueSlice != nil {
		fields[i] = fmt.Sprintf("KeyValueSlice: %v", v.KeyValueSlice)
		i++
	}
	if v.MapType != nil {
		fields[i] = fmt.Sprintf("MapType: %v", v.MapType)
		i++
	}
	if v.ReferenceType != nil {
		fields[i] = fmt.Sprintf("ReferenceType: %v", v.ReferenceType)
		i++
	}
	return fmt.Sprintf("TypeInfo{%v}", strings.Join(fields[:i], ", "))
}

type TypeReference struct {
	Name    string `json:"name"`
	Package string `json:"package"`
}

func (v *TypeReference) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	w, err = wire.NewValueString(v.Package), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *TypeReference) FromWire(w wire.Value) error {
	var err error
	nameIsSet := false
	packageIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Package, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				packageIsSet = true
			}
		}
	}
	if !nameIsSet {
		return errors.New("field Name of TypeReference is required")
	}
	if !packageIsSet {
		return errors.New("field Package of TypeReference is required")
	}
	return nil
}

func (v *TypeReference) String() string {
	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	fields[i] = fmt.Sprintf("Package: %v", v.Package)
	i++
	return fmt.Sprintf("TypeReference{%v}", strings.Join(fields[:i], ", "))
}

type UnsupportedVersionError struct {
	Message *string `json:"message,omitempty"`
}

func (v *UnsupportedVersionError) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *UnsupportedVersionError) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *UnsupportedVersionError) String() string {
	var fields [1]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	return fmt.Sprintf("UnsupportedVersionError{%v}", strings.Join(fields[:i], ", "))
}

func (v *UnsupportedVersionError) Error() string {
	return v.String()
}

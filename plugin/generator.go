package plugin

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/printer"
	"go/token"
	"sort"
	"text/template"

	"golang.org/x/tools/go/ast/astutil"

	"github.com/thriftrw/thriftrw-go/internal/goast"
	"github.com/thriftrw/thriftrw-go/plugin/api"
)

type templateOpts struct {
	funcs map[string]interface{}
}

// TemplateOption TODO
type TemplateOption struct {
	apply func(*templateOpts)
}

// TemplateFunc TODO
func TemplateFunc(name string, f interface{}) TemplateOption {
	return TemplateOption{apply: func(t *templateOpts) {
		t.funcs[name] = f
	}}
}

func buildTemplateOptions(opts []TemplateOption) *templateOpts {
	t := templateOpts{funcs: make(map[string]interface{})}
	for _, o := range opts {
		o.apply(&t)
	}
	return &t
}

// GoFileFromTemplate generates a Go file from the given template and template
// data.
//
// The templating system follows the text/template templating format but with "<"
// and ">" as the delimiters.
//
// The following functions are provided inside the template:
//
// import: Use this if you need to import other packages. Import may be called
// anywhere in the template with an import path to ensure that that package is
// imported in the generated file. The import is automatically converted into
// a named import if there's a conflict with another import. This returns the
// imported name of the package. Use the return value in the template to
// reference the imported package.
//
// 	<$wire := import "github.com/thriftrw/thriftrw-go/wire">
// 	var value <$wire.Value>
//
// formatType: Formats a api.Type into a Go type representation, automatically
// importing packages needed for type references.
//
// 	var value <formatType .Type>
//
// More functions may be added to the template using the TemplateFunc
// template option.
//
// Code generated by this is automatically reformatted.
func GoFileFromTemplate(filename, tmpl string, data interface{}, opts ...TemplateOption) ([]byte, error) {
	// TODO(abg): It might make sense to also accept the target import path so
	// that we know in formatType whether we need to import something or not. It
	// could be optional using TemplateOption.

	globals := make(map[string]struct{}) // names of globals

	imports := make(map[string]string)       // import path -> import name or empty string
	importedNames := make(map[string]string) // import path -> chosen name

	timport := func(path string) string {
		if name, ok := importedNames[path]; ok {
			return name
		}

		name := goast.DeterminePackageName(path)

		importedName := name
		for i := 2; ; i++ {
			if _, conflict := globals[importedName]; !conflict {
				break
			}
			importedName = fmt.Sprintf("%s%d", name, i)
		}

		if importedName == name {
			imports[path] = ""
		} else {
			imports[path] = importedName
		}
		importedNames[path] = importedName
		globals[importedName] = struct{}{}

		return importedName
	}

	var formatType func(*api.Type) (string, error)
	formatType = func(t *api.Type) (string, error) {
		switch {
		case t.SimpleType != nil:
			switch *t.SimpleType {
			case api.SimpleTypeBool:
				return "bool", nil
			case api.SimpleTypeByte:
				return "byte", nil
			case api.SimpleTypeInt8:
				return "int8", nil
			case api.SimpleTypeInt16:
				return "int16", nil
			case api.SimpleTypeInt32:
				return "int32", nil
			case api.SimpleTypeInt64:
				return "int64", nil
			case api.SimpleTypeFloat64:
				return "float64", nil
			case api.SimpleTypeString:
				return "string", nil
			case api.SimpleTypeStructEmpty:
				return "struct{}", nil
			default:
				return "", fmt.Errorf("unknown simple type: %v", *t.SimpleType)
			}
		case t.SliceType != nil:
			v, err := formatType(t.SliceType)
			if err != nil {
				return "", err
			}

			return "[]" + v, nil
		case t.KeyValueSliceType != nil:
			k, err := formatType(t.KeyValueSliceType.Left)
			if err != nil {
				return "", err
			}

			v, err := formatType(t.KeyValueSliceType.Right)
			return fmt.Sprintf("[]struct{Key %v; Value %v}", k, v), err
		case t.MapType != nil:
			k, err := formatType(t.MapType.Left)
			if err != nil {
				return "", err
			}

			v, err := formatType(t.MapType.Right)
			return fmt.Sprintf("map[%v]%v", k, v), err
		case t.ReferenceType != nil:
			importName := timport(t.ReferenceType.Package)
			return importName + "." + t.ReferenceType.Name, nil
		case t.PointerType != nil:
			v, err := formatType(t.PointerType)
			if err != nil {
				return "", err
			}

			return "*" + v, nil
		default:
			return "", fmt.Errorf("unknown type: %v", t)
		}
	}

	templateFuncs := template.FuncMap{
		"import":     timport,
		"formatType": formatType,
	}

	topts := buildTemplateOptions(opts)
	for k, v := range topts.funcs {
		templateFuncs[k] = v
	}

	t, err := template.New(filename).Delims("<", ">").Funcs(templateFuncs).Parse(tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template %q: %v", filename, err)
	}

	var buff bytes.Buffer
	if err := t.Execute(&buff, data); err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, buff.Bytes(), parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse generated code: %v:\n%s", err, buff.String())
	}

	if len(f.Imports) > 0 {
		return nil, fmt.Errorf("Plain imports are not allowed with GoFileFromTemplate. " +
			"Use the import function.")
	}

	importPaths := make([]string, 0, len(imports))
	for path := range imports {
		importPaths = append(importPaths, path)
	}
	sort.Strings(importPaths)
	for _, path := range importPaths {
		astutil.AddNamedImport(fset, f, imports[path], path)
	}

	cfg := printer.Config{
		Mode:     printer.UseSpaces | printer.TabIndent,
		Tabwidth: 8,
	}
	buff = bytes.Buffer{}
	if err := cfg.Fprint(&buff, fset, f); err != nil {
		return nil, err // TODO wrap error
	}

	return buff.Bytes(), nil
}
